     1                                  %macro entrada 1
     2                                      mov eax, 3  ;input
     3                                      mov ebx, 0  ;stdin
     4                                      mov ecx, %1 ;endereco destino
     5                                      mov edx, 1  ;qtd bytes
     6                                      int 80h
     7                                  %endmacro
     8                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     9                                  %macro saida 1
    10                                      mov eax, 4     ;output
    11                                      mov ebx, 1     ;stdout
    12                                      mov ecx, %1    ;endereco do valor a ser exibido
    13                                      mov edx, 1     ;qtd bytes do valor
    14                                      int 80h
    15                                  %endmacro
    16                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    17                                  %macro imprimeInt 0 ;imprime inteiro [res] na base que estiver em [base]
    18                                      %%itoa:
    19                                          mov [stackpointer], esp
    20                                          cmp dword[res], 0
    21                                          je %%itoa.zero
    22                                          jl %%itoa.neg
    23                                      
    24                                      %%itoa.nonzero:
    25                                          xor edx, edx
    26                                          mov eax, dword[res]
    27                                          div dword[base]
    28                                          ;edx resto, eax quociente
    29                                          push edx
    30                                      	
    31                                          cmp eax, 0
    32                                          je %%itoa.write
    33                                          mov [res], eax
    34                                          jmp %%itoa.nonzero
    35                                      
    36                                      %%itoa.write:
    37                                          cmp dword[stackpointer], esp
    38                                          je %%fim.macro
    39                                          pop dword[res]
    40                                          add dword[res], 0x30
    41                                          saida res
    42                                          jmp %%itoa.write
    43                                      
    44                                      %%itoa.zero:
    45                                          push dword[res]
    46                                          jmp %%itoa.write
    47                                  
    48                                      %%itoa.neg:
    49                                      	saida minus
    50                                      	neg dword[res]
    51                                      	jmp %%itoa.nonzero
    52                                      
    53                                      %%fim.macro:
    54                                  %endmacro
    55                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    56                                  %macro precedence 1
    57                                  
    58                                  	; 0 precedence
    59                                  	cmp %1, dword '('
    60                                  	je %%p0
    61                                  
    62                                  	; 1 precedence
    63                                  	cmp %1, dword '+'
    64                                  	je %%p1
    65                                  	cmp %1, dword '-'
    66                                  	je %%p1
    67                                  
    68                                  	; 2 precedence
    69                                  	jmp %%p2
    70                                  
    71                                  	%%p0: 
    72                                  		mov [return], dword 0
    73                                  		jmp %%endPrecedence
    74                                  
    75                                  	%%p1:
    76                                  		mov [return], dword 1
    77                                  		jmp %%endPrecedence
    78                                  
    79                                  	%%p2:
    80                                  		mov [return], dword 2
    81                                  
    82                                  	%%endPrecedence:
    83                                  
    84                                  %endmacro
    85                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    86                                  %macro applyOp 3 
    87                                  
    88                                  	mov eax, %1		; eax = num1
    89                                  	mov ebx, %2		; ebx = num2
    90                                  	mov ecx, %3		; ecx = operator
    91                                  
    92                                  	cmp ecx, dword '+'
    93                                  	je %%opAdd
    94                                  
    95                                  	cmp ecx, dword '-'
    96                                  	je %%opSub
    97                                  
    98                                  	cmp ecx, dword '*'
    99                                  	je %%opMul
   100                                  
   101                                  	jmp %%opDiv
   102                                  
   103                                  	%%opAdd:
   104                                  		add eax, ebx  							; eax += ebx
   105                                  		jmp %%ret 
   106                                  
   107                                  	%%opSub:
   108                                  		sub eax, ebx 							; eax -= ebx 
   109                                  		jmp %%ret
   110                                  
   111                                  	%%opMul:
   112                                  		mul ebx      							; eax *= ebx 
   113                                  		jmp %%ret
   114                                  
   115                                  	%%opDiv:
   116                                  		xor edx, edx
   117                                  		div ebx	         						; eax /= ebx
   118                                  		jmp %%ret 
   119                                  
   120                                  	%%ret:
   121                                  		mov [return], eax 					    ; return eax
   122                                  
   123                                  %endmacro
   124                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   125                                  %macro opStack.push 1
   126                                  	mov ebx, [opSize]
   127                                      mov [opStack+ebx*4], %1
   128                                      inc ebx
   129                                      mov [opSize], ebx
   130                                  %endmacro
   131                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   132                                  %macro numStack.push 1
   133                                  	mov ebx, [numSize]
   134                                      mov [numStack+ebx*4], %1
   135                                      inc ebx
   136                                      mov [numSize], ebx
   137                                  %endmacro
   138                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   139                                  %macro getOperands 0
   140                                  	mov ebx, [numSize]				; ebx = numSize
   141                                  	dec ebx							; numStack.pop()
   142                                  	mov ecx, [numStack+ebx*4]		; ecx = numStack.prevtop()
   143                                  	mov [arg2], ecx
   144                                  	dec ebx							; numStack.pop()
   145                                  	mov ecx, [numStack+ebx*4]		; ecx = numStack.prevtop()
   146                                  	mov [arg1], ecx
   147                                  	mov [numSize], ebx 				; numSize -= 2
   148                                  %endmacro
   149                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   150                                  %macro getOperator 0
   151                                  	mov ebx, [opSize]				; ebx = opStack.size()
   152                                  	dec ebx							; opStack.pop()
   153                                  	mov ecx, [opStack+ebx*4]		; ecx = opStack.top() 
   154                                  	mov [arg3], ecx
   155                                  	mov [opSize], ebx 				; opSize -= 1
   156                                  %endmacro
   157                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   158                                  section .bss
   159                                  
   160 00000000 <res 00000004>              stackpointer 	resd 1
   161 00000004 <res 00000004>              res          	resd 1    
   162 00000008 <res 000007D0>              opStack		 	resd 500 ; stack of operators
   163 000007D8 <res 000007D0>              numStack	 	resd 500 ; stack of numbers
   164 00000FA8 <res 00000004>              input        	resd 1
   165 00000FAC <res 00000004>              return   	 	resd 1 ; stores return of macros
   166 00000FB0 <res 00000004>              arg1		 	resd 1
   167 00000FB4 <res 00000004>              arg2		 	resd 1
   168 00000FB8 <res 00000004>              arg3 			resd 1
   169                                      
   170                                  section .data
   171 00000000 0A000000                    newline: 	 	dd 10
   172 00000004 2D000000                    minus:			dd 45
   173 00000008 0A000000                    base: 		 	dd 10
   174 0000000C 00000000                    numSize:		dd 0					; points to one position above top of stack
   175 00000010 00000000                    opSize: 		dd 0					; points to one position above top of stack
   176 00000014 42656D20666F726D61-         wfe:			db "Bem formatada", 10
   177 0000001D 746164610A         
   178 00000022 4572726F2064652066-         bfe:			db "Erro de formatação", 10
   179 0000002B 6F726D617461C3A7C3-
   180 00000034 A36F0A             
   181                                      
   182                                  section .text
   183                                      global main
   184                                  
   185                                  main:
   186                                  
   187                                      entrada input
   188 00000000 B803000000          <1>  mov eax, 3
   189 00000005 BB00000000          <1>  mov ebx, 0
   190 0000000A B9[A80F0000]        <1>  mov ecx, %1
   191 0000000F BA01000000          <1>  mov edx, 1
   192 00000014 CD80                <1>  int 80h
   193 00000016 A1[A80F0000]                mov eax, dword[input]
   194                                  
   195                                      ;while it is a space character, receive another
   196 0000001B 83F820                      cmp eax, dword ' '
   197 0000001E 74E0                        je main
   198                                  
   199                                      ;jumps if it is an end character
   200 00000020 83F828                      cmp eax, dword 40
   201 00000023 0F8C49020000            	jl 	endProgram
   202                                      
   203                                      ;jumps if it isn't a digit
   204 00000029 83F830                      cmp eax, dword '0'
   205 0000002C 7C1E                        jl checkLParen
   206 0000002E 83F839                      cmp eax, dword '9'
   207 00000031 7F19                        jg checkLParen
   208                                  
   209                                      ;push the number onto numStack 
   210 00000033 83E830                      sub eax, dword '0'
   211                                      numStack.push eax
   212 00000036 8B1D[0C000000]      <1>  mov ebx, [numSize]
   213 0000003C 89049D[D8070000]    <1>  mov [numStack+ebx*4], %1
   214 00000043 43                  <1>  inc ebx
   215 00000044 891D[0C000000]      <1>  mov [numSize], ebx
   216                                      
   217 0000004A EBB4                        jmp main
   218                                  
   219                                  checkLParen:
   220                                  	;jumps if it isn't an opening parentheses
   221 0000004C 83F828                      cmp eax, '('
   222 0000004F 7516                        jne checkRParen
   223                                      
   224                                      ;push opening parentheses onto opStack
   225                                      opStack.push eax
   226 00000051 8B1D[10000000]      <1>  mov ebx, [opSize]
   227 00000057 89049D[08000000]    <1>  mov [opStack+ebx*4], %1
   228 0000005E 43                  <1>  inc ebx
   229 0000005F 891D[10000000]      <1>  mov [opSize], ebx
   230 00000065 EB99                        jmp main
   231                                  
   232                                  checkRParen:
   233                                  	;check if it isn't a closing parentheses
   234 00000067 83F829                      cmp eax, ')'
   235 0000006A 0F85BB000000                jne checkOp
   236                                      
   237                                      loop1:
   238                                  
   239                                      	;checks for balanced parentheses in the expression
   240                                      	
   241                                      	;checks if opStack is empty 
   242 00000070 8B1D[10000000]             		mov ebx, [opSize]
   243 00000076 83FB00                      	cmp ebx, dword 0
   244 00000079 0F8466030000                	je error
   245                                  
   246                                      	;get operator from opStack to [arg3]
   247                                      	getOperator
   248 0000007F 8B1D[10000000]      <1>  mov ebx, [opSize]
   249 00000085 4B                  <1>  dec ebx
   250 00000086 8B0C9D[08000000]    <1>  mov ecx, [opStack+ebx*4]
   251 0000008D 890D[B80F0000]      <1>  mov [arg3], ecx
   252 00000093 891D[10000000]      <1>  mov [opSize], ebx
   253                                  
   254                                      	;if operator is '(': break
   255 00000099 833D[B80F0000]28            	cmp [arg3], dword '('
   256 000000A0 0F8480000000                	je endloop
   257                                      	
   258                                      	;else, get two operands from numStack to [arg1] and [arg2]
   259                                      	getOperands
   260 000000A6 8B1D[0C000000]      <1>  mov ebx, [numSize]
   261 000000AC 4B                  <1>  dec ebx
   262 000000AD 8B0C9D[D8070000]    <1>  mov ecx, [numStack+ebx*4]
   263 000000B4 890D[B40F0000]      <1>  mov [arg2], ecx
   264 000000BA 4B                  <1>  dec ebx
   265 000000BB 8B0C9D[D8070000]    <1>  mov ecx, [numStack+ebx*4]
   266 000000C2 890D[B00F0000]      <1>  mov [arg1], ecx
   267 000000C8 891D[0C000000]      <1>  mov [numSize], ebx
   268                                  
   269                                      	applyOp [arg1], [arg2], [arg3] 
   270                              <1> 
   271 000000CE A1[B00F0000]        <1>  mov eax, %1
   272 000000D3 8B1D[B40F0000]      <1>  mov ebx, %2
   273 000000D9 8B0D[B80F0000]      <1>  mov ecx, %3
   274                              <1> 
   275 000000DF 83F92B              <1>  cmp ecx, dword '+'
   276 000000E2 740C                <1>  je %%opAdd
   277                              <1> 
   278 000000E4 83F92D              <1>  cmp ecx, dword '-'
   279 000000E7 740B                <1>  je %%opSub
   280                              <1> 
   281 000000E9 83F92A              <1>  cmp ecx, dword '*'
   282 000000EC 740A                <1>  je %%opMul
   283                              <1> 
   284 000000EE EB0C                <1>  jmp %%opDiv
   285                              <1> 
   286                              <1>  %%opAdd:
   287 000000F0 01D8                <1>  add eax, ebx
   288 000000F2 EB0E                <1>  jmp %%ret
   289                              <1> 
   290                              <1>  %%opSub:
   291 000000F4 29D8                <1>  sub eax, ebx
   292 000000F6 EB0A                <1>  jmp %%ret
   293                              <1> 
   294                              <1>  %%opMul:
   295 000000F8 F7E3                <1>  mul ebx
   296 000000FA EB06                <1>  jmp %%ret
   297                              <1> 
   298                              <1>  %%opDiv:
   299 000000FC 31D2                <1>  xor edx, edx
   300 000000FE F7F3                <1>  div ebx
   301 00000100 EB00                <1>  jmp %%ret
   302                              <1> 
   303                              <1>  %%ret:
   304 00000102 A3[AC0F0000]        <1>  mov [return], eax
   305                              <1> 
   306 00000107 8B15[AC0F0000]              	mov edx, [return]				; edx = applyOp(arg1,arg2,arg3)
   307                                  
   308                                      	;push result in numStack
   309                                      	numStack.push edx
   310 0000010D 8B1D[0C000000]      <1>  mov ebx, [numSize]
   311 00000113 89149D[D8070000]    <1>  mov [numStack+ebx*4], %1
   312 0000011A 43                  <1>  inc ebx
   313 0000011B 891D[0C000000]      <1>  mov [numSize], ebx
   314                                  
   315 00000121 E94AFFFFFF                  	jmp loop1
   316                                  
   317                                      endloop:
   318                                  
   319 00000126 E9D5FEFFFF                  jmp main
   320                                  
   321                                  checkOp:
   322                                  
   323                                      precedence eax ;[return] = 1 para + e - ;[return] = 2 para * e /
   324                              <1> 
   325                              <1> 
   326 0000012B 83F828              <1>  cmp %1, dword '('
   327 0000012E 740C                <1>  je %%p0
   328                              <1> 
   329                              <1> 
   330 00000130 83F82B              <1>  cmp %1, dword '+'
   331 00000133 7413                <1>  je %%p1
   332 00000135 83F82D              <1>  cmp %1, dword '-'
   333 00000138 740E                <1>  je %%p1
   334                              <1> 
   335                              <1> 
   336 0000013A EB18                <1>  jmp %%p2
   337                              <1> 
   338                              <1>  %%p0:
   339 0000013C C705[AC0F0000]0000- <1>  mov [return], dword 0
   340 00000144 0000                <1>
   341 00000146 EB16                <1>  jmp %%endPrecedence
   342                              <1> 
   343                              <1>  %%p1:
   344 00000148 C705[AC0F0000]0100- <1>  mov [return], dword 1
   345 00000150 0000                <1>
   346 00000152 EB0A                <1>  jmp %%endPrecedence
   347                              <1> 
   348                              <1>  %%p2:
   349 00000154 C705[AC0F0000]0200- <1>  mov [return], dword 2
   350 0000015C 0000                <1>
   351                              <1> 
   352                              <1>  %%endPrecedence:
   353                              <1> 
   354 0000015E 8B15[AC0F0000]              mov edx, [return]
   355                                  
   356                                      loop2:
   357                                  
   358                                      	;checks if opStack is empty 
   359 00000164 8B1D[10000000]              	mov ebx, [opSize]
   360 0000016A 83FB00                      	cmp ebx, dword 0
   361 0000016D 0F84E1000000                	je endLoop2
   362                                  
   363                                      	;checks if top operator on opStack has same or greater precedence as [input]
   364 00000173 4B                          	dec ebx				
   365 00000174 8B0C9D[08000000]            	mov ecx, [opStack+ebx*4]
   366                                      	precedence ecx
   367                              <1> 
   368                              <1> 
   369 0000017B 83F928              <1>  cmp %1, dword '('
   370 0000017E 740C                <1>  je %%p0
   371                              <1> 
   372                              <1> 
   373 00000180 83F92B              <1>  cmp %1, dword '+'
   374 00000183 7413                <1>  je %%p1
   375 00000185 83F92D              <1>  cmp %1, dword '-'
   376 00000188 740E                <1>  je %%p1
   377                              <1> 
   378                              <1> 
   379 0000018A EB18                <1>  jmp %%p2
   380                              <1> 
   381                              <1>  %%p0:
   382 0000018C C705[AC0F0000]0000- <1>  mov [return], dword 0
   383 00000194 0000                <1>
   384 00000196 EB16                <1>  jmp %%endPrecedence
   385                              <1> 
   386                              <1>  %%p1:
   387 00000198 C705[AC0F0000]0100- <1>  mov [return], dword 1
   388 000001A0 0000                <1>
   389 000001A2 EB0A                <1>  jmp %%endPrecedence
   390                              <1> 
   391                              <1>  %%p2:
   392 000001A4 C705[AC0F0000]0200- <1>  mov [return], dword 2
   393 000001AC 0000                <1>
   394                              <1> 
   395                              <1>  %%endPrecedence:
   396                              <1> 
   397 000001AE 3915[AC0F0000]              	cmp [return], edx
   398                                  
   399                                      	;if precedence of top operator on opStack < precedence of [input]: break
   400 000001B4 0F8C9A000000                	jl endLoop2
   401                                  
   402                                      	;else, get operator from opStack to [arg3]
   403                                      	getOperator
   404 000001BA 8B1D[10000000]      <1>  mov ebx, [opSize]
   405 000001C0 4B                  <1>  dec ebx
   406 000001C1 8B0C9D[08000000]    <1>  mov ecx, [opStack+ebx*4]
   407 000001C8 890D[B80F0000]      <1>  mov [arg3], ecx
   408 000001CE 891D[10000000]      <1>  mov [opSize], ebx
   409                                  
   410                                      	;get two operands from numStack to [arg1] and [arg2]
   411                                      	getOperands
   412 000001D4 8B1D[0C000000]      <1>  mov ebx, [numSize]
   413 000001DA 4B                  <1>  dec ebx
   414 000001DB 8B0C9D[D8070000]    <1>  mov ecx, [numStack+ebx*4]
   415 000001E2 890D[B40F0000]      <1>  mov [arg2], ecx
   416 000001E8 4B                  <1>  dec ebx
   417 000001E9 8B0C9D[D8070000]    <1>  mov ecx, [numStack+ebx*4]
   418 000001F0 890D[B00F0000]      <1>  mov [arg1], ecx
   419 000001F6 891D[0C000000]      <1>  mov [numSize], ebx
   420                                  
   421                                      	applyOp [arg1], [arg2], [arg3]
   422                              <1> 
   423 000001FC A1[B00F0000]        <1>  mov eax, %1
   424 00000201 8B1D[B40F0000]      <1>  mov ebx, %2
   425 00000207 8B0D[B80F0000]      <1>  mov ecx, %3
   426                              <1> 
   427 0000020D 83F92B              <1>  cmp ecx, dword '+'
   428 00000210 740C                <1>  je %%opAdd
   429                              <1> 
   430 00000212 83F92D              <1>  cmp ecx, dword '-'
   431 00000215 740B                <1>  je %%opSub
   432                              <1> 
   433 00000217 83F92A              <1>  cmp ecx, dword '*'
   434 0000021A 740A                <1>  je %%opMul
   435                              <1> 
   436 0000021C EB0C                <1>  jmp %%opDiv
   437                              <1> 
   438                              <1>  %%opAdd:
   439 0000021E 01D8                <1>  add eax, ebx
   440 00000220 EB0E                <1>  jmp %%ret
   441                              <1> 
   442                              <1>  %%opSub:
   443 00000222 29D8                <1>  sub eax, ebx
   444 00000224 EB0A                <1>  jmp %%ret
   445                              <1> 
   446                              <1>  %%opMul:
   447 00000226 F7E3                <1>  mul ebx
   448 00000228 EB06                <1>  jmp %%ret
   449                              <1> 
   450                              <1>  %%opDiv:
   451 0000022A 31D2                <1>  xor edx, edx
   452 0000022C F7F3                <1>  div ebx
   453 0000022E EB00                <1>  jmp %%ret
   454                              <1> 
   455                              <1>  %%ret:
   456 00000230 A3[AC0F0000]        <1>  mov [return], eax
   457                              <1> 
   458 00000235 8B15[AC0F0000]              	mov edx, [return]				; edx = applyOp(arg1,arg2,arg3)
   459                                  
   460                                      	;push result onto numStack
   461                                      	numStack.push edx
   462 0000023B 8B1D[0C000000]      <1>  mov ebx, [numSize]
   463 00000241 89149D[D8070000]    <1>  mov [numStack+ebx*4], %1
   464 00000248 43                  <1>  inc ebx
   465 00000249 891D[0C000000]      <1>  mov [numSize], ebx
   466                                  
   467 0000024F E910FFFFFF                  	jmp loop2
   468                                  
   469                                  	endLoop2:
   470                                  		;push [input] onto opStack
   471 00000254 A1[A80F0000]            		mov eax, [input]
   472                                  		opStack.push eax
   473 00000259 8B1D[10000000]      <1>  mov ebx, [opSize]
   474 0000025F 89049D[08000000]    <1>  mov [opStack+ebx*4], %1
   475 00000266 43                  <1>  inc ebx
   476 00000267 891D[10000000]      <1>  mov [opSize], ebx
   477                                  
   478 0000026D E98EFDFFFF                  	jmp main  
   479                                      
   480                                  endProgram:
   481                                  ; while the operator stack is not empty:
   482                                  	loop3: 
   483                                  		;checks if opStack is empty 
   484 00000272 8B1D[10000000]          		mov ebx, [opSize]
   485 00000278 83FB00                      	cmp ebx, dword 0
   486 0000027B 0F84A7000000                	je endLoop3
   487                                  
   488                                      	;get operator from opStack to [arg3]
   489                                      	getOperator
   490 00000281 8B1D[10000000]      <1>  mov ebx, [opSize]
   491 00000287 4B                  <1>  dec ebx
   492 00000288 8B0C9D[08000000]    <1>  mov ecx, [opStack+ebx*4]
   493 0000028F 890D[B80F0000]      <1>  mov [arg3], ecx
   494 00000295 891D[10000000]      <1>  mov [opSize], ebx
   495                                  
   496                                      	;if operator is '(': error
   497 0000029B 833D[B80F0000]28            	cmp [arg3], dword '('
   498 000002A2 0F843D010000                	je error
   499                                  
   500                                  		;get two operands from numStack to [arg1] and [arg2]
   501                                  		getOperands
   502 000002A8 8B1D[0C000000]      <1>  mov ebx, [numSize]
   503 000002AE 4B                  <1>  dec ebx
   504 000002AF 8B0C9D[D8070000]    <1>  mov ecx, [numStack+ebx*4]
   505 000002B6 890D[B40F0000]      <1>  mov [arg2], ecx
   506 000002BC 4B                  <1>  dec ebx
   507 000002BD 8B0C9D[D8070000]    <1>  mov ecx, [numStack+ebx*4]
   508 000002C4 890D[B00F0000]      <1>  mov [arg1], ecx
   509 000002CA 891D[0C000000]      <1>  mov [numSize], ebx
   510                                  
   511                                      	applyOp [arg1], [arg2], [arg3]
   512                              <1> 
   513 000002D0 A1[B00F0000]        <1>  mov eax, %1
   514 000002D5 8B1D[B40F0000]      <1>  mov ebx, %2
   515 000002DB 8B0D[B80F0000]      <1>  mov ecx, %3
   516                              <1> 
   517 000002E1 83F92B              <1>  cmp ecx, dword '+'
   518 000002E4 740C                <1>  je %%opAdd
   519                              <1> 
   520 000002E6 83F92D              <1>  cmp ecx, dword '-'
   521 000002E9 740B                <1>  je %%opSub
   522                              <1> 
   523 000002EB 83F92A              <1>  cmp ecx, dword '*'
   524 000002EE 740A                <1>  je %%opMul
   525                              <1> 
   526 000002F0 EB0C                <1>  jmp %%opDiv
   527                              <1> 
   528                              <1>  %%opAdd:
   529 000002F2 01D8                <1>  add eax, ebx
   530 000002F4 EB0E                <1>  jmp %%ret
   531                              <1> 
   532                              <1>  %%opSub:
   533 000002F6 29D8                <1>  sub eax, ebx
   534 000002F8 EB0A                <1>  jmp %%ret
   535                              <1> 
   536                              <1>  %%opMul:
   537 000002FA F7E3                <1>  mul ebx
   538 000002FC EB06                <1>  jmp %%ret
   539                              <1> 
   540                              <1>  %%opDiv:
   541 000002FE 31D2                <1>  xor edx, edx
   542 00000300 F7F3                <1>  div ebx
   543 00000302 EB00                <1>  jmp %%ret
   544                              <1> 
   545                              <1>  %%ret:
   546 00000304 A3[AC0F0000]        <1>  mov [return], eax
   547                              <1> 
   548 00000309 8B15[AC0F0000]              	mov edx, [return]				; edx = applyOp(arg1,arg2,arg3)
   549                                  
   550                                      	;push result onto numStack
   551                                          numStack.push edx
   552 0000030F 8B1D[0C000000]      <1>  mov ebx, [numSize]
   553 00000315 89149D[D8070000]    <1>  mov [numStack+ebx*4], %1
   554 0000031C 43                  <1>  inc ebx
   555 0000031D 891D[0C000000]      <1>  mov [numSize], ebx
   556                                  
   557 00000323 E94AFFFFFF                  	jmp loop3
   558                                  
   559                                      endLoop3:
   560                                  
   561 00000328 B804000000                  	mov eax, 4
   562 0000032D BB01000000                  	mov ebx, 1
   563 00000332 B9[14000000]                	mov ecx, wfe
   564 00000337 BA0E000000                  	mov edx, 14
   565 0000033C CD80                        	int 80h
   566                                  
   567 0000033E A1[D8070000]                	mov eax, [numStack]
   568 00000343 A3[04000000]                	mov [res], eax
   569                                      	imprimeInt
   570                              <1>  %%itoa:
   571 00000348 8925[00000000]      <1>  mov [stackpointer], esp
   572 0000034E 833D[04000000]00    <1>  cmp dword[res], 0
   573 00000355 7449                <1>  je %%itoa.zero
   574 00000357 7C4F                <1>  jl %%itoa.neg
   575                              <1> 
   576                              <1>  %%itoa.nonzero:
   577 00000359 31D2                <1>  xor edx, edx
   578 0000035B A1[04000000]        <1>  mov eax, dword[res]
   579 00000360 F735[08000000]      <1>  div dword[base]
   580                              <1> 
   581 00000366 52                  <1>  push edx
   582                              <1> 
   583 00000367 83F800              <1>  cmp eax, 0
   584 0000036A 7407                <1>  je %%itoa.write
   585 0000036C A3[04000000]        <1>  mov [res], eax
   586 00000371 EBE6                <1>  jmp %%itoa.nonzero
   587                              <1> 
   588                              <1>  %%itoa.write:
   589 00000373 3925[00000000]      <1>  cmp dword[stackpointer], esp
   590 00000379 744B                <1>  je %%fim.macro
   591 0000037B 8F05[04000000]      <1>  pop dword[res]
   592 00000381 8305[04000000]30    <1>  add dword[res], 0x30
   593                              <1>  saida res
   594 00000388 B804000000          <2>  mov eax, 4
   595 0000038D BB01000000          <2>  mov ebx, 1
   596 00000392 B9[04000000]        <2>  mov ecx, %1
   597 00000397 BA01000000          <2>  mov edx, 1
   598 0000039C CD80                <2>  int 80h
   599 0000039E EBD3                <1>  jmp %%itoa.write
   600                              <1> 
   601                              <1>  %%itoa.zero:
   602 000003A0 FF35[04000000]      <1>  push dword[res]
   603 000003A6 EBCB                <1>  jmp %%itoa.write
   604                              <1> 
   605                              <1>  %%itoa.neg:
   606                              <1>  saida minus
   607 000003A8 B804000000          <2>  mov eax, 4
   608 000003AD BB01000000          <2>  mov ebx, 1
   609 000003B2 B9[04000000]        <2>  mov ecx, %1
   610 000003B7 BA01000000          <2>  mov edx, 1
   611 000003BC CD80                <2>  int 80h
   612 000003BE F71D[04000000]      <1>  neg dword[res]
   613 000003C4 EB93                <1>  jmp %%itoa.nonzero
   614                              <1> 
   615                              <1>  %%fim.macro:
   616                                          saida newline
   617 000003C6 B804000000          <1>  mov eax, 4
   618 000003CB BB01000000          <1>  mov ebx, 1
   619 000003D0 B9[00000000]        <1>  mov ecx, %1
   620 000003D5 BA01000000          <1>  mov edx, 1
   621 000003DA CD80                <1>  int 80h
   622                                  
   623 000003DC B801000000                  	mov eax, 1
   624 000003E1 31DB                       		xor ebx, ebx
   625 000003E3 CD80                        	int 80h
   626                                  
   627                                  error:
   628 000003E5 B804000000                  mov eax, 4
   629 000003EA BB01000000                  mov ebx, 1
   630 000003EF B9[22000000]                mov ecx, bfe
   631 000003F4 BA15000000                  mov edx, 21
   632 000003F9 CD80                        int 80h
   633                                  
   634 000003FB B801000000                  mov eax, 1
   635 00000400 31DB                        xor ebx, ebx
   636 00000402 CD80                        int 80h
   637                                  
   638                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;    
